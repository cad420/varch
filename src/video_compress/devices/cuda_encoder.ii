#include <vocomp/video/devices/cuda_encoder.hpp>
#include <cudafx/driver/context.hpp>
#include <nvcodec/NvEncoderCuda.h>

namespace vol
{
VM_BEGIN_MODULE( video )

struct CudaEncoderImpl
{
	CudaEncoderImpl( uint32_t width, uint32_t height, NV_ENC_BUFFER_FORMAT format ) :
	  _( ctx, width, height, format )
	{
	}

	cufx::drv::Context ctx = 0;
	NvEncoderCuda _;
};

CudaEncoder::CudaEncoder( uint32_t width, uint32_t height, PixelFormat format ) :
  _( [&] {
	  NV_ENC_BUFFER_FORMAT nv_format;
	  get_pixel_format( &nv_format, format );
	  return new CudaEncoderImpl( width, height, nv_format );
  }() )
{
}

CudaEncoder::~CudaEncoder()
{
}

void CudaEncoder::encode( Reader &reader, Writer &writer )
{
	auto &_ = this->_->_;

	int nFrameSize = _.GetFrameSize();
	std::unique_ptr<uint8_t[]> pHostFrame( new uint8_t[ nFrameSize ] );
	int nFrame = 0;

	while ( true ) {
		// For receiving encoded packets
		std::vector<std::vector<uint8_t>> vPacket;
		// Load the next frame from disk
		auto nRead = reader.read( reinterpret_cast<char *>( pHostFrame.get() ), nFrameSize );
		if ( nRead == nFrameSize ) {
			const NvEncInputFrame *encoderInputFrame = _.GetNextInputFrame();
			NvEncoderCuda::CopyToDeviceFrame( this->_->ctx, pHostFrame.get(), 0, (CUdeviceptr)encoderInputFrame->inputPtr,
											  (int)encoderInputFrame->pitch,
											  _.GetEncodeWidth(),
											  _.GetEncodeHeight(),
											  CU_MEMORYTYPE_HOST,
											  encoderInputFrame->bufferFormat,
											  encoderInputFrame->chromaOffsets,
											  encoderInputFrame->numChromaPlanes );
			_.EncodeFrame( vPacket );
		} else {
			_.EndEncode( vPacket );
		}

		nFrame += (int)vPacket.size();

		for ( auto &packet : vPacket ) {
			writer.write( reinterpret_cast<char *>( packet.data() ), packet.size() );
		}

		if ( nRead != nFrameSize ) break;
	}

	// vm::println( "Total frames encoded: {}", nFrame );
}

void *CudaEncoder::get_nv_impl()
{
	return &_->_;
}

VM_END_MODULE()

}  // namespace vol
