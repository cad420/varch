#include <vocomp/video/devices/gl_encoder.hpp>
#include <nvcodec/NvEncoderGL.h>
#include <GL/gl.h>

namespace vol
{
VM_BEGIN_MODULE( video )

struct GLEncoderImpl
{
	GLEncoderImpl( uint32_t width, uint32_t height, NV_ENC_BUFFER_FORMAT format ) :
	  _( width, height, format ),
	  width( width ),
	  height( height )
	{
	}

	NvEncoderGL _;
	uint32_t width, height;
};

GLEncoder::GLEncoder( uint32_t width, uint32_t height, PixelFormat format ) :
  _( [&] {
	  NV_ENC_BUFFER_FORMAT nv_format;
	  get_pixel_format( &nv_format, format );
	  return new GLEncoderImpl( width, height, nv_format );
  }() )
{
}

GLEncoder::~GLEncoder()
{
}

void GLEncoder::encode( Reader &reader, Writer &writer )
{
	auto &_ = this->_->_;

	int nFrameSize = _.GetFrameSize();
	std::unique_ptr<uint8_t[]> pHostFrame( new uint8_t[ nFrameSize ] );
	int nFrame = 0;

	while ( true ) {
		auto nRead = reader.read( reinterpret_cast<char *>( pHostFrame.get() ), nFrameSize );
		const NvEncInputFrame *encoderInputFrame = _.GetNextInputFrame();

		NV_ENC_INPUT_RESOURCE_OPENGL_TEX *pResource = (NV_ENC_INPUT_RESOURCE_OPENGL_TEX *)encoderInputFrame->inputPtr;
		glBindTexture( pResource->target, pResource->texture );
		glTexSubImage2D( pResource->target, 0, 0, 0,
						 this->_->width, this->_->height * 3 / 2,
						 GL_RED, GL_UNSIGNED_BYTE, pHostFrame.get() );
		glBindTexture( pResource->target, 0 );

		std::vector<std::vector<uint8_t>> vPacket;
		if ( nRead == nFrameSize ) {
			_.EncodeFrame( vPacket );
		} else {
			_.EndEncode( vPacket );
		}

		nFrame += (int)vPacket.size();

		for ( auto &packet : vPacket ) {
			writer.write( reinterpret_cast<char *>( packet.data() ), packet.size() );
		}

		if ( nRead != nFrameSize ) break;
	}
}

void *GLEncoder::get_nv_impl()
{
	return &_->_;
}

VM_END_MODULE()

}  // namespace vol
