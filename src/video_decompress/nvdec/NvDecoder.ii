/*
* Copyright 2017-2019 NVIDIA Corporation.  All rights reserved.
*
* Please refer to the NVIDIA end user license agreement (EULA) associated
* with this source code for terms and conditions that govern your use of
* this software. Any use, reproduction, disclosure, or distribution of
* this software and related documentation outside the terms of the EULA
* is strictly prohibited.
*
*/

#include <iostream>
#include <algorithm>
#include <chrono>

#include "nvcodec/nvcuvid.h"
#include "nvcodec/NvCodecUtils.h"
#include "nvcodec/NvDecoder.h"

#define START_TIMER auto start = std::chrono::high_resolution_clock::now();
#define STOP_TIMER( print_message ) std::cout << print_message << std::chrono::duration_cast<std::chrono::milliseconds>( std::chrono::high_resolution_clock::now() - start ).count() \
											  << " ms " << std::endl;

#define CUDA_DRVAPI_CALL( call )                                                                                 \
	do {                                                                                                         \
		CUresult err__ = call;                                                                                   \
		if ( err__ != CUDA_SUCCESS ) {                                                                           \
			const char *szErrName = NULL;                                                                        \
			cuGetErrorName( err__, &szErrName );                                                                 \
			std::ostringstream errorLog;                                                                         \
			errorLog << "CUDA driver API error " << szErrName;                                                   \
			throw NVDECException::makeNVDECException( errorLog.str(), err__, __FUNCTION__, __FILE__, __LINE__ ); \
		}                                                                                                        \
	} while ( 0 )

static float GetChromaHeightFactor( cudaVideoChromaFormat eChromaFormat )
{
	float factor = 0.5;
	switch ( eChromaFormat ) {
	case cudaVideoChromaFormat_Monochrome:
		factor = 0.0;
		break;
	case cudaVideoChromaFormat_420:
		factor = 0.5;
		break;
	case cudaVideoChromaFormat_422:
		factor = 1.0;
		break;
	case cudaVideoChromaFormat_444:
		factor = 1.0;
		break;
	}

	return factor;
}

static int GetChromaPlaneCount( cudaVideoChromaFormat eChromaFormat )
{
	int numPlane = 1;
	switch ( eChromaFormat ) {
	case cudaVideoChromaFormat_Monochrome:
		numPlane = 0;
		break;
	case cudaVideoChromaFormat_420:
		numPlane = 1;
		break;
	case cudaVideoChromaFormat_444:
		numPlane = 2;
		break;
	}

	return numPlane;
}

/* Return value from HandleVideoSequence() are interpreted as   :
*  0: fail, 1: succeeded, > 1: override dpb size of parser (set by CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces while creating parser)
*/
int NvDecoder::HandleVideoSequence( CUVIDEOFORMAT *pVideoFormat )
{
	START_TIMER

	int nDecodeSurface = pVideoFormat->min_num_decode_surfaces;

	CUVIDDECODECAPS decodecaps;
	memset( &decodecaps, 0, sizeof( decodecaps ) );

	decodecaps.eCodecType = pVideoFormat->codec;
	decodecaps.eChromaFormat = pVideoFormat->chroma_format;
	decodecaps.nBitDepthMinus8 = pVideoFormat->bit_depth_luma_minus8;

	CUDA_DRVAPI_CALL( cuCtxPushCurrent( m_cuContext ) );
	NVDEC_API_CALL( cuvidGetDecoderCaps( &decodecaps ) );
	CUDA_DRVAPI_CALL( cuCtxPopCurrent( NULL ) );

	if ( !decodecaps.bIsSupported ) {
		NVDEC_THROW_ERROR( "Codec not supported on this GPU", CUDA_ERROR_NOT_SUPPORTED );
		return nDecodeSurface;
	}

	if ( ( pVideoFormat->coded_width > decodecaps.nMaxWidth ) ||
		 ( pVideoFormat->coded_height > decodecaps.nMaxHeight ) ) {
		std::ostringstream errorString;
		errorString << std::endl
					<< "Resolution          : " << pVideoFormat->coded_width << "x" << pVideoFormat->coded_height << std::endl
					<< "Max Supported (wxh) : " << decodecaps.nMaxWidth << "x" << decodecaps.nMaxHeight << std::endl
					<< "Resolution not supported on this GPU";

		const std::string cErr = errorString.str();
		NVDEC_THROW_ERROR( cErr, CUDA_ERROR_NOT_SUPPORTED );
		return nDecodeSurface;
	}

	if ( ( pVideoFormat->coded_width >> 4 ) * ( pVideoFormat->coded_height >> 4 ) > decodecaps.nMaxMBCount ) {
		std::ostringstream errorString;
		errorString << std::endl
					<< "MBCount             : " << ( pVideoFormat->coded_width >> 4 ) * ( pVideoFormat->coded_height >> 4 ) << std::endl
					<< "Max Supported mbcnt : " << decodecaps.nMaxMBCount << std::endl
					<< "MBCount not supported on this GPU";

		const std::string cErr = errorString.str();
		NVDEC_THROW_ERROR( cErr, CUDA_ERROR_NOT_SUPPORTED );
		return nDecodeSurface;
	}

	if ( m_nWidth && m_nLumaHeight && m_nChromaHeight ) {
		// cuvidCreateDecoder() has been called before, and now there's possible config change
		return ReconfigureDecoder( pVideoFormat );
	}

	// eCodec has been set in the constructor (for parser). Here it's set again for potential correction
	m_eCodec = pVideoFormat->codec;
	m_eChromaFormat = pVideoFormat->chroma_format;
	m_nBitDepthMinus8 = pVideoFormat->bit_depth_luma_minus8;
	m_nBPP = m_nBitDepthMinus8 > 0 ? 2 : 1;

	if ( m_eChromaFormat == cudaVideoChromaFormat_420 )
		m_eOutputFormat = pVideoFormat->bit_depth_luma_minus8 ? cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12;
	else if ( m_eChromaFormat == cudaVideoChromaFormat_444 )
		m_eOutputFormat = pVideoFormat->bit_depth_luma_minus8 ? cudaVideoSurfaceFormat_YUV444_16Bit : cudaVideoSurfaceFormat_YUV444;

	m_videoFormat = *pVideoFormat;

	CUVIDDECODECREATEINFO videoDecodeCreateInfo = { 0 };
	videoDecodeCreateInfo.CodecType = pVideoFormat->codec;
	videoDecodeCreateInfo.ChromaFormat = pVideoFormat->chroma_format;
	videoDecodeCreateInfo.OutputFormat = m_eOutputFormat;
	videoDecodeCreateInfo.bitDepthMinus8 = pVideoFormat->bit_depth_luma_minus8;
	if ( pVideoFormat->progressive_sequence )
		videoDecodeCreateInfo.DeinterlaceMode = cudaVideoDeinterlaceMode_Weave;
	else
		videoDecodeCreateInfo.DeinterlaceMode = cudaVideoDeinterlaceMode_Adaptive;
	videoDecodeCreateInfo.ulNumOutputSurfaces = 2;
	// With PreferCUVID, JPEG is still decoded by CUDA while video is decoded by NVDEC hardware
	videoDecodeCreateInfo.ulCreationFlags = cudaVideoCreate_PreferCUVID;
	videoDecodeCreateInfo.ulNumDecodeSurfaces = nDecodeSurface;
	videoDecodeCreateInfo.vidLock = m_ctxLock;
	videoDecodeCreateInfo.ulWidth = pVideoFormat->coded_width;
	videoDecodeCreateInfo.ulHeight = pVideoFormat->coded_height;
	if ( m_nMaxWidth < (int)pVideoFormat->coded_width )
		m_nMaxWidth = pVideoFormat->coded_width;
	if ( m_nMaxHeight < (int)pVideoFormat->coded_height )
		m_nMaxHeight = pVideoFormat->coded_height;
	videoDecodeCreateInfo.ulMaxWidth = m_nMaxWidth;
	videoDecodeCreateInfo.ulMaxHeight = m_nMaxHeight;

	if ( !( m_cropRect.r && m_cropRect.b ) && !( m_resizeDim.w && m_resizeDim.h ) ) {
		m_nWidth = pVideoFormat->display_area.right - pVideoFormat->display_area.left;
		m_nLumaHeight = pVideoFormat->display_area.bottom - pVideoFormat->display_area.top;
		videoDecodeCreateInfo.ulTargetWidth = pVideoFormat->coded_width;
		videoDecodeCreateInfo.ulTargetHeight = pVideoFormat->coded_height;
	} else {
		if ( m_resizeDim.w && m_resizeDim.h ) {
			videoDecodeCreateInfo.display_area.left = pVideoFormat->display_area.left;
			videoDecodeCreateInfo.display_area.top = pVideoFormat->display_area.top;
			videoDecodeCreateInfo.display_area.right = pVideoFormat->display_area.right;
			videoDecodeCreateInfo.display_area.bottom = pVideoFormat->display_area.bottom;
			m_nWidth = m_resizeDim.w;
			m_nLumaHeight = m_resizeDim.h;
		}

		if ( m_cropRect.r && m_cropRect.b ) {
			videoDecodeCreateInfo.display_area.left = m_cropRect.l;
			videoDecodeCreateInfo.display_area.top = m_cropRect.t;
			videoDecodeCreateInfo.display_area.right = m_cropRect.r;
			videoDecodeCreateInfo.display_area.bottom = m_cropRect.b;
			m_nWidth = m_cropRect.r - m_cropRect.l;
			m_nLumaHeight = m_cropRect.b - m_cropRect.t;
		}
		videoDecodeCreateInfo.ulTargetWidth = m_nWidth;
		videoDecodeCreateInfo.ulTargetHeight = m_nLumaHeight;
	}

	m_nChromaHeight = (int)( m_nLumaHeight * GetChromaHeightFactor( videoDecodeCreateInfo.ChromaFormat ) );
	m_nNumChromaPlanes = GetChromaPlaneCount( videoDecodeCreateInfo.ChromaFormat );
	m_nSurfaceHeight = videoDecodeCreateInfo.ulTargetHeight;
	m_nSurfaceWidth = videoDecodeCreateInfo.ulTargetWidth;
	m_displayRect.b = videoDecodeCreateInfo.display_area.bottom;
	m_displayRect.t = videoDecodeCreateInfo.display_area.top;
	m_displayRect.l = videoDecodeCreateInfo.display_area.left;
	m_displayRect.r = videoDecodeCreateInfo.display_area.right;

	CUDA_DRVAPI_CALL( cuCtxPushCurrent( m_cuContext ) );
	NVDEC_API_CALL( cuvidCreateDecoder( &m_hDecoder, &videoDecodeCreateInfo ) );
	CUDA_DRVAPI_CALL( cuCtxPopCurrent( NULL ) );
	STOP_TIMER( "Session Initialization Time: " );
	return nDecodeSurface;
}

int NvDecoder::ReconfigureDecoder( CUVIDEOFORMAT *pVideoFormat )
{
	if ( pVideoFormat->bit_depth_luma_minus8 != m_videoFormat.bit_depth_luma_minus8 || pVideoFormat->bit_depth_chroma_minus8 != m_videoFormat.bit_depth_chroma_minus8 ) {
		NVDEC_THROW_ERROR( "Reconfigure Not supported for bit depth change", CUDA_ERROR_NOT_SUPPORTED );
	}

	if ( pVideoFormat->chroma_format != m_videoFormat.chroma_format ) {
		NVDEC_THROW_ERROR( "Reconfigure Not supported for chroma format change", CUDA_ERROR_NOT_SUPPORTED );
	}

	bool bDecodeResChange = !( pVideoFormat->coded_width == m_videoFormat.coded_width && pVideoFormat->coded_height == m_videoFormat.coded_height );
	bool bDisplayRectChange = !( pVideoFormat->display_area.bottom == m_videoFormat.display_area.bottom && pVideoFormat->display_area.top == m_videoFormat.display_area.top && pVideoFormat->display_area.left == m_videoFormat.display_area.left && pVideoFormat->display_area.right == m_videoFormat.display_area.right );

	int nDecodeSurface = pVideoFormat->min_num_decode_surfaces;

	if ( ( pVideoFormat->coded_width > m_nMaxWidth ) || ( pVideoFormat->coded_height > m_nMaxHeight ) ) {
		// For VP9, let driver  handle the change if new width/height > maxwidth/maxheight
		if ( m_eCodec != cudaVideoCodec_VP9 ) {
			NVDEC_THROW_ERROR( "Reconfigure Not supported when width/height > maxwidth/maxheight", CUDA_ERROR_NOT_SUPPORTED );
		}
		return 1;
	}

	if ( !bDecodeResChange ) {
		// if the coded_width/coded_height hasn't changed but display resolution has changed, then need to update width/height for
		// correct output without cropping. Example : 1920x1080 vs 1920x1088
		if ( bDisplayRectChange ) {
			m_nWidth = pVideoFormat->display_area.right - pVideoFormat->display_area.left;
			m_nLumaHeight = pVideoFormat->display_area.bottom - pVideoFormat->display_area.top;
			m_nChromaHeight = int( m_nLumaHeight * GetChromaHeightFactor( pVideoFormat->chroma_format ) );
			m_nNumChromaPlanes = GetChromaPlaneCount( pVideoFormat->chroma_format );
		}

		// no need for reconfigureDecoder(). Just return
		return 1;
	}

	CUVIDRECONFIGUREDECODERINFO reconfigParams = { 0 };

	reconfigParams.ulWidth = m_videoFormat.coded_width = pVideoFormat->coded_width;
	reconfigParams.ulHeight = m_videoFormat.coded_height = pVideoFormat->coded_height;

	// Dont change display rect and get scaled output from decoder. This will help display app to present apps smoothly
	reconfigParams.display_area.bottom = m_displayRect.b;
	reconfigParams.display_area.top = m_displayRect.t;
	reconfigParams.display_area.left = m_displayRect.l;
	reconfigParams.display_area.right = m_displayRect.r;
	reconfigParams.ulTargetWidth = m_nSurfaceWidth;
	reconfigParams.ulTargetHeight = m_nSurfaceHeight;
	reconfigParams.ulNumDecodeSurfaces = nDecodeSurface;

	START_TIMER
	CUDA_DRVAPI_CALL( cuCtxPushCurrent( m_cuContext ) );
	NVDEC_API_CALL( cuvidReconfigureDecoder( m_hDecoder, &reconfigParams ) );
	CUDA_DRVAPI_CALL( cuCtxPopCurrent( NULL ) );
	STOP_TIMER( "Session Reconfigure Time: " );

	return nDecodeSurface;
}

/* Return value from HandlePictureDecode() are interpreted as:
*  0: fail, >=1: succeeded
*/
int NvDecoder::HandlePictureDecode( CUVIDPICPARAMS *pPicParams )
{
	if ( !m_hDecoder ) {
		NVDEC_THROW_ERROR( "Decoder not initialized.", CUDA_ERROR_NOT_INITIALIZED );
		return false;
	}
	NVDEC_API_CALL( cuvidDecodePicture( m_hDecoder, pPicParams ) );
	return 1;
}

/* Return value from HandlePictureDisplay() are interpreted as:
*  0: fail, >=1: succeeded
*/
int NvDecoder::HandlePictureDisplay( CUVIDPARSERDISPINFO *pDispInfo )
{
	CUVIDPROCPARAMS videoProcessingParameters = {};
	videoProcessingParameters.progressive_frame = pDispInfo->progressive_frame;
	videoProcessingParameters.second_field = pDispInfo->repeat_first_field + 1;
	videoProcessingParameters.top_field_first = pDispInfo->top_field_first;
	videoProcessingParameters.unpaired_field = pDispInfo->repeat_first_field < 0;
	videoProcessingParameters.output_stream = m_cuvidStream;

	CUdeviceptr dpSrcFrame = 0;
	unsigned int nSrcPitch = 0;
	NVDEC_API_CALL( cuvidMapVideoFrame( m_hDecoder, pDispInfo->picture_index, &dpSrcFrame,
										&nSrcPitch, &videoProcessingParameters ) );

	CUVIDGETDECODESTATUS DecodeStatus;
	memset( &DecodeStatus, 0, sizeof( DecodeStatus ) );
	CUresult result = cuvidGetDecodeStatus( m_hDecoder, pDispInfo->picture_index, &DecodeStatus );
	if ( result == CUDA_SUCCESS && ( DecodeStatus.decodeStatus == cuvidDecodeStatus_Error || DecodeStatus.decodeStatus == cuvidDecodeStatus_Error_Concealed ) ) {
		printf( "Decode Error occurred\n" );
	}

	if ( on_picture_display.has() ) {
		( *on_picture_display )( dpSrcFrame, nSrcPitch );
	} else {
		uint8_t *pDecodedFrame = nullptr;
		{
			std::lock_guard<std::mutex> lock( m_mtxVPFrame );
			if ( (unsigned)++m_nDecodedFrame > m_vpFrame.size() ) {
				// Not enough frames in stock
				uint8_t *pFrame = NULL;
				pFrame = new uint8_t[ GetFrameSize() ];
				m_vpFrame.push_back( pFrame );
			}
			pDecodedFrame = m_vpFrame[ m_nDecodedFrame - 1 ];
		}

		CUDA_DRVAPI_CALL( cuCtxPushCurrent( m_cuContext ) );
		CUDA_MEMCPY2D m = { 0 };
		m.srcMemoryType = CU_MEMORYTYPE_DEVICE;
		m.srcDevice = dpSrcFrame;
		m.srcPitch = nSrcPitch;
		m.dstMemoryType = CU_MEMORYTYPE_HOST;
		m.dstDevice = ( CUdeviceptr )( m.dstHost = pDecodedFrame );
		m.dstPitch = m_nDeviceFramePitch ? m_nDeviceFramePitch : m_nWidth * m_nBPP;
		m.WidthInBytes = m_nWidth * m_nBPP;
		m.Height = m_nLumaHeight;
		CUDA_DRVAPI_CALL( cuMemcpy2DAsync( &m, m_cuvidStream ) );

		m.srcDevice = ( CUdeviceptr )( (uint8_t *)dpSrcFrame + m.srcPitch * m_nSurfaceHeight );
		m.dstDevice = ( CUdeviceptr )( m.dstHost = pDecodedFrame + m.dstPitch * m_nLumaHeight );
		m.Height = m_nChromaHeight;
		CUDA_DRVAPI_CALL( cuMemcpy2DAsync( &m, m_cuvidStream ) );

		if ( m_nNumChromaPlanes == 2 ) {
			m.srcDevice = ( CUdeviceptr )( (uint8_t *)dpSrcFrame + m.srcPitch * m_nSurfaceHeight * 2 );
			m.dstDevice = ( CUdeviceptr )( m.dstHost = pDecodedFrame + m.dstPitch * m_nLumaHeight * 2 );
			m.Height = m_nChromaHeight;
			CUDA_DRVAPI_CALL( cuMemcpy2DAsync( &m, m_cuvidStream ) );
		}
		CUDA_DRVAPI_CALL( cuStreamSynchronize( m_cuvidStream ) );
		CUDA_DRVAPI_CALL( cuCtxPopCurrent( NULL ) );
	}

	NVDEC_API_CALL( cuvidUnmapVideoFrame( m_hDecoder, dpSrcFrame ) );
	return 1;
}

NvDecoder::NvDecoder( CUcontext cuContext, cudaVideoCodec eCodec,
					  bool bLowLatency, const Rect *pCropRect, const Dim *pResizeDim, int maxWidth, int maxHeight ) :
  m_cuContext( cuContext ),
  m_eCodec( eCodec ),
  m_nMaxWidth( maxWidth ),
  m_nMaxHeight( maxHeight )
{
	if ( pCropRect ) m_cropRect = *pCropRect;
	if ( pResizeDim ) m_resizeDim = *pResizeDim;

	NVDEC_API_CALL( cuvidCtxLockCreate( &m_ctxLock, cuContext ) );

	CUVIDPARSERPARAMS videoParserParameters = {};
	videoParserParameters.CodecType = eCodec;
	videoParserParameters.ulMaxNumDecodeSurfaces = 1;
	videoParserParameters.ulMaxDisplayDelay = bLowLatency ? 0 : 1;
	videoParserParameters.pUserData = this;
	videoParserParameters.pfnSequenceCallback = HandleVideoSequenceProc;
	videoParserParameters.pfnDecodePicture = HandlePictureDecodeProc;
	videoParserParameters.pfnDisplayPicture = HandlePictureDisplayProc;
	NVDEC_API_CALL( cuvidCreateVideoParser( &m_hParser, &videoParserParameters ) );
}

NvDecoder::~NvDecoder()
{
	START_TIMER
	cuCtxPushCurrent( m_cuContext );
	cuCtxPopCurrent( NULL );

	if ( m_hParser ) {
		cuvidDestroyVideoParser( m_hParser );
	}

	if ( m_hDecoder ) {
		cuvidDestroyDecoder( m_hDecoder );
	}

	std::lock_guard<std::mutex> lock( m_mtxVPFrame );
	// if ( m_vpFrame.size() != m_nFrameAlloc ) {
	// 	//LOG(WARNING) << "nFrameAlloc(" << m_nFrameAlloc << ") != m_vpFrame.size()(" << m_vpFrame.size() << ")";
	// }
	for ( uint8_t *pFrame : m_vpFrame ) {
		delete[] pFrame;
	}
	cuvidCtxLockDestroy( m_ctxLock );
	STOP_TIMER( "Session Deinitialization Time: " );
}

bool NvDecoder::Decode( const uint8_t *pData, int nSize, uint8_t ***pppFrame, int *pnFrameReturned, uint32_t flags, CUstream stream )
{
	m_nDecodedFrame = 0;
	CUVIDSOURCEDATAPACKET packet = { 0 };
	packet.payload = pData;
	packet.payload_size = nSize;
	packet.flags = flags;
	if ( !pData || nSize == 0 ) {
		packet.flags |= CUVID_PKT_ENDOFSTREAM;
	}
	m_cuvidStream = stream;
	NVDEC_API_CALL( cuvidParseVideoData( m_hParser, &packet ) );
	m_cuvidStream = 0;

	if ( m_nDecodedFrame > 0 ) {
		if ( pppFrame ) {
			m_vpFrameRet.clear();
			std::lock_guard<std::mutex> lock( m_mtxVPFrame );
			m_vpFrameRet.insert( m_vpFrameRet.begin(), m_vpFrame.begin(), m_vpFrame.begin() + m_nDecodedFrame );
			*pppFrame = &m_vpFrameRet[ 0 ];
		}
	}
	if ( pnFrameReturned ) {
		*pnFrameReturned = m_nDecodedFrame;
	}
	return true;
}
